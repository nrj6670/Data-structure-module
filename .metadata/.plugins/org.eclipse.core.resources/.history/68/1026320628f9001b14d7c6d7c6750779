package com.app.core.binarytree;

public class BinaryTree implements BinaryTreeIntf {
	BinaryTreeNode root;
	
	private static int index = 0;

	public BinaryTree() {
		root = null;
	}

	private int[] PreOrderHelper(BinaryTreeNode root) {
		// if root is empty then Stop
		if (root == null) {
			return null;
		}

		// Process root node's data.
		//System.out.println(root.data);

		// if root node's left child exists then
		if (root.lChild != null) {
			// PreOrder(root's left child)
			PreOrderHelper(root.lChild);
		}

		// if root node's right child exists then
		if (root.rChild != null) {
			// PreOrder(root's right child)
			PreOrderHelper(root.rChild);
		}

		return null;
	}

	@Override
	public int[] PreOrder() {
		return PreOrderHelper(root);
	}

	public int[] BuildTreeForPreOrder() {
		int[] element = new int[4];
		element[0] = 1;
		element[1] = 2;
		element[2] = 4;
		element[3] = 3;

		root = new BinaryTreeNode(1);
		root.lChild = new BinaryTreeNode(2);
		root.rChild = new BinaryTreeNode(3);
		root.lChild.lChild = new BinaryTreeNode(4);

		return element;
	}
	
	private void postOrderHelper(BinaryTreeNode root, int [] postOrderTraversal) {
		if(root == null) {
			return;
		}
		
		postOrderHelper(root.lChild, postOrderTraversal);
		postOrderHelper(root.rChild, postOrderTraversal);
		postOrderTraversal[index] = root.data;
		index += 1;
	}

	@Override
	public int[] PostOrder() {
		int size = GetNodesCount();
		int [] postOrderArr = new int[size];
		index = 0;
		postOrderHelper(root, postOrderArr);
		return postOrderArr;
	}
	
	private void inOrderHelper(BinaryTreeNode root, int [] inOrderTraversal) {
		if(root == null) {
			return;
		}
		
		inOrderHelper(root.lChild, inOrderTraversal);
		inOrderTraversal[index] = root.data;
		index += 1;
		inOrderHelper(root.rChild, inOrderTraversal);
	}

	@Override
	public int[] InOrder() {
		int size = GetNodesCount();
		int [] inOrderArr = new int[size];
		index = 0;
		inOrderHelper(root, inOrderArr);
		return inOrderArr;
	}
	
	private int getNodesCountUtil(BinaryTreeNode root) {
		if(root == null) {
			return 0;
		}
		
		int size = 1;
		
		size += getNodesCountUtil(root.lChild);
		size += getNodesCountUtil(root.rChild);
		
		return size;
	}

	@Override
	public int GetNodesCount() {
		return getNodesCountUtil(root);
	}
	
	private int getTreeHeight(BinaryTreeNode root) {
		if(root == null) {
			return 0;
		}
		
		return 1 + Math.max(getTreeHeight(root.lChild) ,  getTreeHeight(root.rChild));
	}

	@Override
	public int Height() {
		return getTreeHeight(root);
	}
	
	private int findFrequencyHelper(BinaryTreeNode root, int element) {
		if(root == null) {
			return 0;
		}
		
		int counter = 0;
		
		if(root.data == element) {
			counter += 1;
		}
		
		return counter + findFrequencyHelper(root.lChild, element)
						+ findFrequencyHelper(root.rChild, element);
	}

	@Override
	public int FindFrequency(int element) {
		return findFrequencyHelper(root, element);
	}
	
	private int countLeafNodesHelper(BinaryTreeNode root) {
		if(root == null) {
			return 0;
		}
		
		if(root.lChild == null && root.rChild == null) {
			return 1;
		}
		
		return countLeafNodesHelper(root.lChild) 
				+ countLeafNodesHelper(root.rChild);
	}

	@Override
	public int CountLeafNodes() {
		return countLeafNodesHelper(root);
	}
	
	private void makeMirrorTreeHelper(BinaryTreeNode root) {
		if(root == null) {
			return;
		}
		makeMirrorTreeHelper(root.lChild);
		makeMirrorTreeHelper(root.rChild);
		BinaryTreeNode temp = root.lChild;
		root.lChild = root.rChild;
		root.rChild = temp;
	}

	@Override
	public int MakeMirror() {
		makeMirrorTreeHelper(root);
		return 1;
	}
}
